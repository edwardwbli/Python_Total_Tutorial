
# 调试工具

## 调试模块
pdb是python自带的调试模块,它可以在交互环境中使用,也可以在terminal中作为python的一个模式使用

> 要调试的脚本:


```python
%%writefile counter.py
#!/usr/bin/env python
# --*-- coding:utf-8 --*--
from __future__ import print_function

class Counter(object):
    """一个计数器
    用法:
    >>> counter1 = Counter()
    >>> counter1()
    1
    >>> counter1()
    2
    >>> counter2 = Counter(lambda : 2,-3)
    >>> counter2()
    -1
    >>> counter2()
    1
    """
    def __str__(self):
        return "state:"+str(self.value)
    def __repr__(self):
        return self.__str__
    def __call__(self):
        def count():
            self.value += self.func()
            return self.value
        return count()
    
    def __init__(self,func=lambda : 1,start=0):
        self.value = start
        self.func = func 
test = Counter()
test()
test()
print(test)
if __name__=="__main__":
    counter1 = Counter()
    counter2 = Counter()
    for i in range(10):
        counter1()
    for i in range(8):
        counter2()
    if counter1.value == counter2.value:
        print("not success")
    else: 
        print("don't known")
        
    
    import doctest
    doctest.testmod(verbose=True)

```

    Writing counter.py


> 命令行调试

    python -m pdb counter.py
    
在jupyter中无法演示,请自己试试

> 在交互shell中调试

    import pdb
    import counter
    pdb.run('counter.test()')

> 常用的调试命令

可以用help命令来查看

> 在ipython中调用pdb

ipython内置了魔法命令`%pdb`可以在程序出错的时候自动跳入debug


```python
%pdb
from __future__ import print_function

class Counter(object):
    """一个计数器
    用法:
    >>> counter1 = Counter()
    >>> counter1()
    1
    >>> counter1()
    2
    >>> counter2 = Counter(lambda : 2,-3)
    >>> counter2()
    -1
    >>> counter2()
    1
    """
    def __str__(self):
        return "state:"+str(self.value)
    def __repr__(self):
        return self.__str__
    def __call__(self):
        def count():
            self.value += self.func()
            return self.value
        return count()
    
    def __init__(self,func=lambda : 1,start=0):
        self.value = start
        self.func = func 
test = Counter()
test()
test()
print(test)
assert test.value == 1 
```

    Automatic pdb calling has been turned ON
    state:2



    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-2-16cc623a427d> in <module>()
         33 test()
         34 print(test)
    ---> 35 assert test.value == 1
    

    AssertionError: 


    > [0;32m<ipython-input-2-16cc623a427d>[0m(35)[0;36m<module>[0;34m()[0m
    [0;32m     31 [0;31m[0mtest[0m [0;34m=[0m [0mCounter[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     32 [0;31m[0mtest[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     33 [0;31m[0mtest[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     34 [0;31m[0mprint[0m[0;34m([0m[0mtest[0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m---> 35 [0;31m[0;32massert[0m [0mtest[0m[0;34m.[0m[0mvalue[0m [0;34m==[0m [0;36m1[0m[0;34m[0m[0m
    [0m
    ipdb> help
    
    Documented commands (type help <topic>):
    ========================================
    EOF    c          d        h         next    pp       retval  u          whatis
    a      cl         debug    help      p       psource  run     unalias    where 
    alias  clear      disable  ignore    pdef    q        rv      undisplay
    args   commands   display  interact  pdoc    quit     s       unt      
    b      condition  down     j         pfile   r        source  until    
    break  cont       enable   jump      pinfo   restart  step    up       
    bt     continue   exit     n         pinfo2  return   tbreak  w        
    
    Miscellaneous help topics:
    ==========================
    pdb  exec
    
    Undocumented commands:
    ======================
    l  list  ll  longlist
    
    ipdb> exit


##  调用追踪

调试的时候我们除了想知道哪条代码错了,也会想知道是谁调用了这条错误的代码,这个时候调用追踪模块就有用了

>一个简单的例子 


```python
import traceback
def func():
    s =  traceback.extract_stack()
    print('%s Invoked me!'%s[-2][2])
    
def a():
    func()
b = lambda :func()
```


```python
a()
```

    a Invoked me!



```python
b()
```

    <lambda> Invoked me!


## 测试运行时间模块

Python中的timeit是测试代码执行效率的工具.可以用命令行直接测试脚本,也可以测试代码字符串的效率,当然最简单的还是直接用ipython的内置timeit魔法命令测某段代码的效率


```python
import timeit
t = timeit.Timer('map(lambda x: x**2,range(1000))')
t.timeit()
```




    1.00792034000915



在命令行中我们呢也可以这样使用


```python
!python -m timeit -s "map(lambda x: x**2,range(1000))"
```

    10000000 loops, best of 3: 0.0225 usec per loop


在jupyter中更加简单了,可以使用魔法命令来测试


```python
%timeit  map(lambda x: x**2,range(1000))
```

    1000000 loops, best of 3: 930 ns per loop

