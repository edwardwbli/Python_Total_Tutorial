
# 测试工具

python自带的测试框架有两个

## 说明文档测试模块(doctest)

doctest 并不是测试文档用的测试,而是用文档测试代码,听上去蛮酷的~

doctest 模块会搜索那些看起来像交互式会话的 Python 代码片段，然后尝试执行并验证结果

doctest 的编写过程就仿佛你真的在一个交互式 shell（比如 idle）中导入了要测试的模块，然后开始一条条地测试模块里的函数一样。实际上有很多人也是这么做的，他们写好一个模块后，就在 shell 里挨个测试函数，最后把 shell 会话复制粘贴成 doctest 用例。 


> 一个简单的例子:


```python
%%writefile func_oper.py
#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""\
这里可以写用到多个函数的

>>> summing(multiply(2,3),multiply(2,3))
12

"""
from functools import reduce
from operator import mul,add

def multiply(*args):
    """\
    这里可以写单元测试
    >>> multiply(2,3)
    6
    >>> multiply('baka~',3)
    'baka~baka~baka~'
    """
    return reduce(mul,args)

def  summing(*args):
    """\
    这里可以写单元测试
    >>> summing(2,3)
    5
    >>> summing(2,3,4)
    9
    """
    return reduce(add,args)

if __name__ == '__main__':
    import doctest
    doctest.testmod(verbose=True)
```

    Writing func_oper.py



```python
%run func_oper.py
```

    Trying:
        summing(multiply(2,3),multiply(2,3))
    Expecting:
        12
    ok
    Trying:
        multiply(2,3)
    Expecting:
        6
    ok
    Trying:
        multiply('baka~',3)
    Expecting:
        'baka~baka~baka~'
    ok
    Trying:
        summing(2,3)
    Expecting:
        5
    ok
    Trying:
        summing(2,3,4)
    Expecting:
        9
    ok
    3 items passed all tests:
       1 tests in __main__
       2 tests in __main__.multiply
       2 tests in __main__.summing
    5 tests in 3 items.
    5 passed and 0 failed.
    Test passed.


    if __name__ == '__main__':
        import doctest
        doctest.testmod(verbose=True)

这种方式很适合在写简单模块包的时候用,因为模块都是引用来用的.


```python
!python -m doctest -v func_oper.py
```

    Trying:
        summing(multiply(2,3),multiply(2,3))
    Expecting:
        12
    ok
    Trying:
        multiply(2,3)
    Expecting:
        6
    ok
    Trying:
        multiply('baka~',3)
    Expecting:
        'baka~baka~baka~'
    ok
    Trying:
        summing(2,3)
    Expecting:
        5
    ok
    Trying:
        summing(2,3,4)
    Expecting:
        9
    ok
    3 items passed all tests:
       1 tests in func_oper
       2 tests in func_oper.multiply
       2 tests in func_oper.summing
    5 tests in 3 items.
    5 passed and 0 failed.
    Test passed.


这种方式启动测试就不用在写

    if __name__ == '__main__':
        import doctest
        doctest.testmod(verbose=True)
        
这段了,效果也是一样

doctest也可以在文件外写测试,但这么搞就有点本末倒置了,因此这边就不写了

## 单元测试框架(unittest)

unittest 从名字上看，它是一个单元测试框架；从官方文档的字数上看，它的能力应该比 doctest 强一些。

使用 unittest 的标准流程为：

+ 从 unittest.TestCase 派生一个子类
+ 在类中定义各种以 `"test_"` 打头的方法
+ 通过 unittest.main() 函数来启动测试

unittest 的一个很有用的特性是 TestCase 的 setUp() 和 tearDown() 方法，它们提供了为测试进行准备和扫尾工作的功能，听起来就像上下文管理器一样。这种功能很适合用在测试对象需要复杂执行环境的情况下。 




```python
%%writefile func_oper.py
#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""\
这里可以写用到多个函数的

>>> summing(multiply(2,3),multiply(2,3))
12

"""
from functools import reduce
from operator import mul,add

def multiply(*args):
    """\
    这里可以写单元测试
    >>> multiply(2,3)
    6
    >>> multiply('baka~',3)
    'baka~baka~baka~'
    """
    return reduce(mul,args)

def summing(*args):
    """\
    这里可以写单元测试
    >>> summing(2,3)
    5
    >>> summing(2,3,4)
    9
    """
    return reduce(add,args)

if __name__ == '__main__':
    import doctest
    doctest.testmod(verbose=True)
```

    Overwriting func_oper.py



```python
%%writefile test_my.py
#!/usr/bin/env python
# -*- coding:utf-8 -*-
import unittest
    
from func_oper import multiply,summing

class Test_mul(unittest.TestCase):
    def setUp(self):
        pass
    def test_number_3_4(self):
        self.assertEqual(multiply(3,4),12)
    def test_string_a_3(self):
        self.assertEqual(multiply('a',3),'aaa')
        
class Test_sum(unittest.TestCase):
    def setUp(self):
        pass
    def test_number_3_4(self):
        self.assertEqual(summing(3,4),7)
    def test_number_3_4_5(self):
        self.assertEqual(summing(3,4,5),12)
class TestCase1(unittest.TestCase):
    def setUp(self):
        pass
    def test_sum_mul_2_3_mul_2_3(self):
        self.assertEqual(summing(multiply(2,3),multiply(2,3)),12)

if __name__ == '__main__':
    unittest.main()


```

    Overwriting test_my.py



```python
%run test_my.py -v
```

    test_sum_mul_2_3_mul_2_3 (__main__.TestCase1) ... ok
    test_number_3_4 (__main__.Test_mul) ... ok
    test_string_a_3 (__main__.Test_mul) ... ok
    test_number_3_4 (__main__.Test_sum) ... ok
    test_number_3_4_5 (__main__.Test_sum) ... ok
    
    ----------------------------------------------------------------------
    Ran 5 tests in 0.008s
    
    OK



```python
!python -m unittest discover -v
```

    test_sum_mul_2_3_mul_2_3 (test_my.TestCase1) ... ok
    test_number_3_4 (test_my.Test_mul) ... ok
    test_string_a_3 (test_my.Test_mul) ... ok
    test_number_3_4 (test_my.Test_sum) ... ok
    test_number_3_4_5 (test_my.Test_sum) ... ok
    
    ----------------------------------------------------------------------
    Ran 5 tests in 0.000s
    
    OK


## 单元测试框架(nose)

Nose是一个流行的单元测试第三方框架,虽然是第三方框架,但因为太过常用放在基础应用部分介绍,相比较unittest但使用起来比较麻烦,基本没啥人用


新建一个test.py的文件:


```python
%%writefile test.py

from func_oper import multiply,summing

def test_multiply():
    assert multiply(2,3)==6
def test_multiply_n():
    assert multiply('baka~',3)=='baka~baka~baka~'
    
def test_summing():
    assert summing(2,3) == 5
def test_mul_sum():
    assert summing(multiply(2,3),multiply(2,3)) == 12
```

    Writing test.py



```python
!nosetests --tests=test.py -v
```

    test.test_multiply ... ok
    test.test_multiply_n ... ok
    test.test_summing ... ok
    test.test_mul_sum ... ok
    
    ----------------------------------------------------------------------
    Ran 4 tests in 0.001s
    
    OK


# 代码覆盖率

光测试无法看到我们的测试是否完全

    pip install coverage
    
安装好后在shell中cd退回到项目根地址前一地址

    nosetests -w <path> --with-coverage --cover-package=<package> -v


```python
!nosetests --tests=test.py --with-coverage -v
```

    test.test_multiply ... ok
    test.test_multiply_n ... ok
    test.test_summing ... ok
    test.test_mul_sum ... ok
    
    Name           Stmts   Miss  Cover
    ----------------------------------
    func_oper.py      10      2    80%
    ----------------------------------------------------------------------
    Ran 4 tests in 0.008s
    
    OK


### 输出为html用于了解详细情况

这虽然可以大体上看到测试的覆盖率,但我们任然不知道哪些被用到了哪些没有,可以通过使用输出为html文件来获取详细信息

    nosetests -w <path> --with-coverage --cover-package=<package> -v --cover-html
    
这样在项目根目录下会生成一个cover文件夹,里面有静态页面可以看分析结果




```python
!nosetests --tests=test.py --with-coverage -v --cover-html
```

    test.test_multiply ... ok
    test.test_multiply_n ... ok
    test.test_summing ... ok
    test.test_mul_sum ... ok
    
    Name           Stmts   Miss  Cover
    ----------------------------------
    func_oper.py      10      2    80%
    ----------------------------------------------------------------------
    Ran 4 tests in 0.002s
    
    OK


# BDD测试工具

## TDD 与 BDD

测试驱动开发(TDD)是现代开发模式

测试驱动开发大概的流程是:

+ 先针对每个功能点抽象出接口代码，
+ 然后编写单元测试代码，
+ 接下来实现接口
+ 运行单元测试代码

循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。

它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等

python中的测试框架比如自带unittest模块和最常见的nose模块普遍比较老,自带的断言方式也是比较传统的assert,这种测试写起来会比较容易没条理,无法直观的看到哪些测了哪些不完善.

敏捷开发提倡的行为驱动开发(BDD)原则实际上可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范.

BDD的核心价值是体现在正确的对系统行为进行设计，所以它并非一种行之有效的测试方法。它强调的是系统最终的实现与用户期望的行为是一致的、验证代码实现是否符合设计目标。但是它本身并不强调对系统功能、性能以及边界值等的健全性做保证，无法像完整的测试一样发现系统的各种问题。但BDD倡导的用简洁的自然语言描述系统行为的理念，可以明确的根据设计产生测试，并保障测试用例的质量。

简单说,BDD测试的代码应该是不会编程的人也能看懂的.这样

python中比较好的BDD测试工具就是PyVows了,它主要包括三个方面:

+ BDD风格的断言

+ BDD风格的测试代码结构

+ 测试结果统计与分析



首先是安装

    pip install pyvows


```python
import pyvows
```

# BDD风格的断言

TDD风格的断言最典型的就是python自带的关键字

```python
assert
```

它会根据后面的第一个表达式的真值判断是不是要抛出一个`assertionError`,并接收第二个参数(可选)作为assertError的错误信息


```python
assert 1==0 , "应该是0"
```


    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-27-ddc949274534> in <module>()
    ----> 1 assert 1==0 , "应该是0"
    

    AssertionError: 应该是0


这种方式很"程序员思维",英语翻译过来就是

`断言 1 == 0 ,应该是0`

没有主语,语音并不清晰,或者说不会编程的人看来会很难受

BDD要求的是语义清晰接近自然语言,当然了自然语言指的是英语,明显这是不符合要求的,pyvow的断言库则是不同的风格,要使用BDD风格的测试,需要引入expect模块


```python
from pyvows import expect
```


```python
expect([1,2,3,4,5]).to_length(5)
```




    <preggy.core.Expect at 0x10bd9cc18>




```python
try:
    expect([1,2,3,4]).to_length(5)
    
except Exception as e:
    print(e)
```

    Expected topic([1, 2, 3, 4]) to have 5 of length, but it has 4


## 自带的断言方法:




### 断言相等

+ expect(4).to_equal(4)
 
+ expect(5).Not.to_equal(4)

### 断言相似


+ expect("sOmE RandOm     CAse StRiNG").to_be_like('some random case string')
 
+ expect(1).to_be_like(1)
+ expect(1).to_be_like(1.0)
+ expect(1).to_be_like(long(1))
 
+ expect([1, 2, 3]).to_be_like([3, 2, 1])
+ expect([1, 2, 3]).to_be_like((3, 2, 1))
+ expect([[1, 2], [3,4]]).to_be_like([4, 3], [2, 1]])
 
+ expect({ 'some': 1, 'key': 2 }).to_be_like({ 'key': 2, 'some': 1 })
 
+ expect("sOmE RandOm     CAse StRiNG").Not.to_be_like('other string')
+ expect(1).Not_to_be_like(2)
+ expect([[1, 2], [3,4]]).Not.to_be_like([4, 4], [2, 1]])
+ expect({ 'some': 1, 'key': 2 }).Not.to_be_like({ 'key': 3, 'some': 4 })

### 断言类型


+ expect(os.path).to_be_a_function()
+ expect(1).to_be_numeric()
+ expect("some").Not.to_be_a_function()
+ expect("some").Not.to_be_numeric()

### 断言真值


+ expect(True).to_be_true()
+ expect("some").to_be_true()
+ expect([1, 2, 3]).to_be_true()
+ expect({ "a": "b" }).to_be_true()
+ expect(1).to_be_true()
+ expect(False).to_be_false()
+ expect(None).to_be_false()
+ expect("").to_be_false()
+ expect(0).to_be_false()
+ expect([]).to_be_false()
+ expect({}).to_be_false()

### 断言空值

+ expect(None).to_be_null()
+ expect("some").Not.to_be_null()


### 断言包含

+ expect([1, 2, 3]).to_include(2)
+ expect((1, 2, 3)).to_include(2)
+ expect("123").to_include("2")
+ expect({ "a": 1, "b": 2, "c": 3}).to_include("b")
+ expect([1, 3]).Not.to_include(2)

### 正则匹配断言

+ expect('some').to_match(r'^[a-z]+')
+ expect("Some").Not.to_match(r'^[a-z]+')

### 断言长度

+ expect([1, 2, 3]).to_length(3)
+ expect((1, 2, 3)).to_length(3)
+ expect("abc").to_length(3)
+ expect({ "a": 1, "b": 2, "c": 3}).to_length(3)
+ expect([1]).Not.to_length(3)

### 断言空容器

+ expect([]).to_be_empty()
+ expect(tuple()).to_be_empty()
+ expect({}).to_be_empty()
+ expect("").to_be_empty()

### 断言某错误


+ expect(RuntimeError()).to_be_an_error()
+ expect(RuntimeError()).to_be_an_error_like(RuntimeError)
+ expect(ValueError("error")).to_have_an_error_message_of("error")
+ expect("I'm not an error").Not.to_be_an_error()
+ expect(ValueError()).Not.to_be_an_error_like(RuntimeError)
+ expect(ValueError("some")).Not.to_have_an_error_message_of("error")

### 自定义断言

我们可以用`@Vows.create_assertions `自定义一个BDD风格的断言


```python
@pyvows.Vows.create_assertions
def to_be_bigger_than(topic, expected):
    return topic > expected
```


```python
expect(2).to_be_bigger_than(3)
```


    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-33-e99a6b74ac2f> in <module>()
    ----> 1 expect(2).to_be_bigger_than(3)
    

    /usr/local/lib/python3.5/site-packages/preggy/core.py in _assert_topic(*args, **kw)
        283         def _assert_topic(*args, **kw):
        284             # Allows chained calls to assertions, such as `expect(topic).to_be_true()`.
    --> 285             return _registered_assertions[method_name](self.topic, *args, **kw)
        286 
        287         return _assert_topic


    /usr/local/lib/python3.5/site-packages/preggy/core.py in wrapper(*args, **kw)
         56     @functools.wraps(func)
         57     def wrapper(*args, **kw):
    ---> 58         func(*args, **kw)
         59         return Expect(args[0])
         60 


    /usr/local/lib/python3.5/site-packages/preggy/core.py in test_assertion(*args)
        124             raw_msg = utils.format_assertion_msg(func.humanized, *args)
        125             err_msg = raw_msg.format(*args)
    --> 126             raise AssertionError(err_msg)
        127         return Expect(args[0])
        128 


    AssertionError: Expected topic(2) to be bigger than 3


与此同时,他还会自动的创建假值对应的断言


```python
expect(2).not_to_be_bigger_than(3)
```




    <preggy.core.Expect at 0x10bdbacc0>



如果并不是如这个这么简单的,那可以使用装饰器`@Vows.assertion`来自定义


```python
@pyvows.Vows.assertion
def to_be_a_positive_integer(topic):
    # You can use normal assert statements...
    assert type(topic) == int, "Expected {0} to be a positive integer, but it's not even an integer".format(topic)
    assert topic > 0, "Expected {0} to be a positive integer, but it's a negative integer".format(topic)
    assert topic != 0, "Expected {0} to be a positive integer, but it's 0".format(topic)
 
@pyvows.Vows.assertion
def not_to_be_a_positive_integer(topic):
    # ...or, you might prefer to raise AssertionErrors manually.
    if isinstance(topic, int) and topic <= 0:
        raise AssertionError("Expected {0} not to be a positive integer, but it was.".format(topic))
```


```python
expect(5).to_be_a_positive_integer()
```




    <preggy.core.Expect at 0x10bdceeb8>




```python
expect(-5).Not.to_be_a_positive_integer()
```


    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-37-4f5df6ae7c15> in <module>()
    ----> 1 expect(-5).Not.to_be_a_positive_integer()
    

    /usr/local/lib/python3.5/site-packages/preggy/core.py in _assert_topic(*args, **kw)
        283         def _assert_topic(*args, **kw):
        284             # Allows chained calls to assertions, such as `expect(topic).to_be_true()`.
    --> 285             return _registered_assertions[method_name](self.topic, *args, **kw)
        286 
        287         return _assert_topic


    /usr/local/lib/python3.5/site-packages/preggy/core.py in wrapper(*args, **kw)
         56     @functools.wraps(func)
         57     def wrapper(*args, **kw):
    ---> 58         func(*args, **kw)
         59         return Expect(args[0])
         60 


    <ipython-input-35-f6f197349291> in not_to_be_a_positive_integer(topic)
         10     # ...or, you might prefer to raise AssertionErrors manually.
         11     if isinstance(topic, int) and topic <= 0:
    ---> 12         raise AssertionError("Expected {0} not to be a positive integer, but it was.".format(topic))
    

    AssertionError: Expected -5 not to be a positive integer, but it was.



```python
expect(-5).not_to_be_a_positive_integer()
```


    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-38-ab2da4144153> in <module>()
    ----> 1 expect(-5).not_to_be_a_positive_integer()
    

    /usr/local/lib/python3.5/site-packages/preggy/core.py in _assert_topic(*args, **kw)
        283         def _assert_topic(*args, **kw):
        284             # Allows chained calls to assertions, such as `expect(topic).to_be_true()`.
    --> 285             return _registered_assertions[method_name](self.topic, *args, **kw)
        286 
        287         return _assert_topic


    /usr/local/lib/python3.5/site-packages/preggy/core.py in wrapper(*args, **kw)
         56     @functools.wraps(func)
         57     def wrapper(*args, **kw):
    ---> 58         func(*args, **kw)
         59         return Expect(args[0])
         60 


    <ipython-input-35-f6f197349291> in not_to_be_a_positive_integer(topic)
         10     # ...or, you might prefer to raise AssertionErrors manually.
         11     if isinstance(topic, int) and topic <= 0:
    ---> 12         raise AssertionError("Expected {0} not to be a positive integer, but it was.".format(topic))
    

    AssertionError: Expected -5 not to be a positive integer, but it was.


# 测试代码结构

测试代码主要就是由两种结构组成

+ 批:
    
    由`@Vows.batch`装饰器装饰的`Vows.Context`的子类,意思是一个批次的测试,你可以定义很多的批次,
    
+ 测试环境:
    `Vows.Context`的子类,一个子类代表一个环境,他们是相互独立的,也会异步执行,在最底层的测试环境中必须定义
    
    + topic方法
            
        这个方法返回一个要测得对象,如果要测得对象我们本来就希望它是有错误的那可以在topic上用装饰器`@Vows.capture_error`修饰,代表对象错误
            
    + 需要测试的对应方法
    
        这些方法需要用断言来断言是否正确
        
基本结构就是这样:

```
测试程序   → 批*
            批   → 环境*
                   环境 → 要测对象? 
                          要测对象  → 对象功能*
```    
    
加`*`表示可以有多个

> 例子:

测试以下代码`dog.py`:

```python
# coding:utf-8
from __future__ import print_function


class Dog(object):

    def __str__(self):
        return "<Dog:{self.name}--{self.age}>".format(self=self)

    def __repr__(self):
        return self.__str__()

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self, food):
        return "{self.name} is eating {food}".format(self=self, food=food)

```

测试代码`test/dog_test.py`:

```python
# coding:utf-8
from __future__ import print_function,absolute_import

from pyvows import Vows,expect
import sys
import os
from forgery_py import name as random_name
from random import randint

root = os.path.dirname(os.path.dirname(__file__))
sys.path[0] = root

import dog


@Vows.batch
class DogTest(Vows.Context):
    def topic(self):
        name = random_name.full_name()
        age = randint(18,30)
        return dog.Dog(name,age)
 
    def can_eat(self, topic):
        food = "apple"
        expect(topic.eat(food)).to_equal("{topic.name} is eating {food}".format(topic=topic, food=food))
 
    def can_be_print(self, topic):
        expect(str(topic)).to_equal("<Dog:{topic.name}--{topic.age}>".format(topic=topic))
```

### 运行测试:
cd到项目根目录,然后执行
```
!pyvows test/ --pattern='*_test.py'
```

运行测试的参数可以有:

Options:

+ -p, --pattern	识别什么是测试文件
+ -c, --cover	文件覆盖率
+ -l, --cover-package	包覆盖率
+ -o, --cover-omit	检测排除的文件
+ -t, --cover-threshold	Coverage number below which coverage is considered failing. Defaults to 80.0.
+ -r, --cover-report	报告保存位置.
+ -x, --xunit-output	Enable XUnit output.
+ -f, --xunit-file	Filename of the XUnit output. Defaults to pyvows.xml.
+ -v	Verbosity. Can be supplied multiple times to increase verbosity. Defaults to -vv.
+ --no-color	Does not colorize the output.
+ --help	Show help
+ --version	Show pyvows’ current version

注意:路径有中文就没法检测覆盖率了


```python

```
