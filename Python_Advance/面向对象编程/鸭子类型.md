
# 鸭子类型

鸭子类型与其说是一种类模型不如说是一种思想.要说是什么思想,na大概最接近的说法就是邓爷爷的名言:"不管白猫黑猫,抓得住老鼠的就是好猫."

鸭子类型算是动态语言的最大特点之一了,甚至许多静态语言都有它的实现.像Python,Ruby这种动态语言自不必说,像Go这种静态语言都是鸭子类型,可见其先进性.

那么究竟啥是鸭子类型呢
维基百科中的定义如下:

一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述：

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

具体到Python中,那就是只要可以执行那就不算错.


## 只要有需要的属性就不算错

Python是一行一行运行的,也没有啥类型检测,因此当一个函数定义后它并不知道传入的值是啥样的,举个例子:我们定义3个类


```python
class Have_value(object):
    def __init__(self):
        self.value = 10
        
class Have_morethanvalue(object):
    def __init__(self):
        self.value = 11
        self.more = "more"
class Not_havevalue(object):
    def __init__(self):
        self.more = "more"
        
a = Have_value()
b = Have_morethanvalue()
c = Not_havevalue()
```

这3个类的实例将作为参数传到一个函数中


```python
def print_value(x):
    print(x.value)
```


```python
print_value(a)
```

    10



```python
print_value(b)
```

    11



```python
print_value(c)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-31-c6487757071d> in <module>()
    ----> 1 print_value(c)
    

    <ipython-input-28-a16581644431> in print_value(x)
          1 def print_value(x):
    ----> 2     print(x.value)
    

    AttributeError: 'Not_havevalue' object has no attribute 'value'


 函数只管它找他要的字段(变量或方法名),有就算对,找不到就算错,简单至极的理念

## 只要可以执行就不算错

其实这也是上一条的衍生,Python中定义了一些固有的函数和实现这些函数的运算符(具体可以看运算符重载部分),在这个基础上又可以衍生出更多的函数.而Python解释器只负责取照着这些函数定义的操作去执行而已,只要解释器可以执行,那它就执行,不能执行了就报错.这也是简单明了的理念.我们再来看看之前快速入门中关于多态的例子



```python
class V:
    def __init__(self,x,y):
        self.x = x
        self.y = y
    def __repr__(self):
        return str(self.x)+","+str(self.y)
    def __add__(self,other):
        result = V(self.x+other.x,self.y+other.y)
        return result

class C:
    def __init__(self,x,y,z):
        self.x = x
        self.y = y
        self.z = z
    def __repr__(self):
        return str(self.x)+","+str(self.y)+","+str(self.z)
    def __add__(self,other):
        result = C(self.x+other.x,self.y+other.y,other.z)
        return result

```


```python
c = C(1,2,4)
v = V(3,5)

print(v+c)#4,7
print(c+v)#会报错


```

    4,7



    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-33-5c33a8830c93> in <module>()
          3 
          4 print(v+c)#4,7
    ----> 5 print(c+v)#会报错
          6 


    <ipython-input-32-ab79601830da> in __add__(self, other)
         17         return str(self.x)+","+str(self.y)+","+str(self.z)
         18     def __add__(self,other):
    ---> 19         result = C(self.x+other.x,self.y+other.y,other.z)
         20         return result


    AttributeError: 'V' object has no attribute 'z'


这个例子可以看出,v+c被执行了,因为v的`__add__()`方法可以执行,而c+v就会报错,因为c的`__add__`方法中需要传入的参数有`z`这个字段,而v中没有.

Python是"唯才是举"的坚决执行者,而鸭子类型便是其表现.这种思想直接让Python用户摆脱了类型,接口等契约的限制,节省了大量代码.
