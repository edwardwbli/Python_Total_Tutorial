
# 运算符重载

运算符重载在任何语言中都算得上是高级特性,因为它可以改变语言本身即元编程. Python支持有限的运算符重载,并有几个特殊的运算符可以改变类的一些特性.

常用的预定义方法有:

二元运算符|特殊方法
---|---
+|	`__add__,__radd__`
+=|	`__iaddr__`
-|	`__sub__,__rsub__`
`*`|	`__mul__,__rmul__`
/|	`__div__,__rdiv__,__truediv__,__rtruediv__`
//|`	__floordiv__,__rfloordiv__`
%|	`__mod__,__rmod__`
`**`|	`__pow__,__rpow__`
<<|	`__lshift__,__rlshift__`
`>>`|	`__rshift__,__rrshift__`
`&`|	`__and__,__rand__`
`^`|	`__xor__,__rxor__`
竖线|	`__or__,__ror_`
-=|	`__isub__`
`*=`|	`__imul__`
/=|`__idiv__,__itruediv__`
//=|	`__ifloordiv__`
%=	|`__imod__`
`**=`|	`__ipow__`
`<<=`|	`__ilshift__`
`>>=`	|`__irshift__`
&=	|`__iand__`
`^=`|	`__ixor__`
竖线=|	`__ior__`
==|	`__eq__`
!=,<>|	`__ne__`
`>`|	`__get__`
`<`|	`__lt__`
`>=`|	`__ge__`
`<=`|	`__le__`


特殊方法|重载|调用
---|---|---
`__new__`|创建|在`__init__`之前创建对象
`__init__`|构造函数|对象建立x = CLASS(args)
`__del__`|析构函数|x对象回收
`__call__`|函数调用|x(`*args,**kws`)
`__getattr__`|点运算|x.att
`__setattr__`|属性赋值语句|x.any = value
`__getattribute__`|属性获取|x.any
`__delattr__`|属性删除| del x.any
`__getitem__`|索引运算|x[key]等,没`__iter__`时的for循环和其他迭代器
`__setitem__`|索引赋值|x[key]=value等
`__delitem__`|索引删除| del x[key]
`__len__`|长度|len(x),如果没有`__bool__`真值测试
`__bool__`|布尔测试|bool(x)测试是否为空
`__iter__,__next__`|迭代环境|for循环,next()
`__contains__`|成员关系测试| i in x
`__index__`|整数值|hex(x),bin(x),oct(x)
`__enter__,__exit__`|环境管理| with obj as var
`__get__,__set__,__delete__`|描述符属性|X.attr,X.attr=value,del x.attr
`__enter__`和`__exit__`|上下文运算符和with关键字|---
`__copy__`和`__deepcopy__`|拷贝|---

>例 定义一个数组类,实现减法索引打印等操作


```python
class Array(object):
    def __init__(self,*args):#构造函数
        self.value = args
    def __sub__(self,other):#减法运算符
        if type(other) == int or type(other) == float:
            new = Array(*list(map(lambda x : x-other,self.value)))
            return new
        if type(other) == Array:
            new = Array(*list(map(lambda x,y : x-y,self.value,other.value)))
            return new
        else:
            raise ValueError("Illegal operations")
    def __repr__(self):#打印
        return "Array: "+str(self.value)
    def __str__(self):#字符串化
        return "Array: "+str(self.value)
    def __getitem__(self,index):#索引分片,有了分片也就有了迭代,但不如迭代器好
        new =  Array(*self.value[index])
        return new


```


```python
arr1=Array(1,2,3,4)
```


```python
arr2=Array(10,20,30,40)
```


```python
arr2-arr1
```




    Array: (9, 18, 27, 36)



## 几个重要的运算符

### `__new__`构造运算符


也就是面向对象编程中常提到的构造方法了

这是一旦被调用就会执行的运算符,也是正常情况下一个实例第一个执行的运算符.该方法会返回一个对应对象的实例.我们来看看他的特性


```python
class Test_new(object):
    def __new__(cls):
        print("created")
```


```python
Test_new()
```

    created



```python
Test_new()
```

    created



```python
class Test_new1(object):
    def __new__(cls,*args):
        print("created")
        obj = super(Test_new1,cls).__new__(cls)
        return obj
    def __init__(self,a):
        self.a = a
```

> 例: 建立一个可以记录调用次数的类


```python
class Count_new(object):
    counter = 0
    def __new__(cls):
        cls.counter += 1
        print(cls.counter," times has been called. ")
        return super(Count_new,cls).__new__(cls)
```


```python
Count_new()#没有指定变量也会返回一个对象
```

    3  times has been called. 





    <__main__.Count_new at 0x1082d0c50>




```python
a = Count_new()
```

    4  times has been called. 


> 带参数的`__new__`运算符


```python
class Count_new_withvalue(object):
    counter = 0
    def __new__(cls,value):
        cls.counter += 1
        cls.value = value
        print(cls.counter," times has been called. ")
        return super(Count_new_withvalue,cls).__new__(cls)
```


```python
cnwv1 = Count_new_withvalue(1)
```

    1  times has been called. 



```python
Count_new_withvalue.value
```




    1




```python
cnwv1.value
```




    1



### `__init__`实例初始化

最常见的运算符重载应用就是`__init__`方法了,即实例初始化方法.该方法无返回值.

这个方法我们在将继承的时候就有过接触,所以不多说,主要看看他和`__new__`的关系


```python
class Count_new_init(object):
    counter = 0
    def __new__(cls):
        cls.counter += 1
        print(cls.counter," times has been called. ")
        return object.__new__(cls)
    def __init__(self):
        self.name = self.counter<<2
        print("My name is ",self.name," , you've Created me!")
```


```python
Count_new_init()
```

    1  times has been called. 
    My name is  4  , you've Created me!





    <__main__.Count_new_init at 0x10b80cf28>




```python
a = Count_new_init()
```

    2  times has been called. 
    My name is  8  , you've Created me!



```python
b = Count_new_init()
```

    3  times has been called. 
    My name is  12  , you've Created me!


可以看到总是先执行`__new__`再执行`__init__`


```python
c = b.__new__(Count_new_init)
```

    4  times has been called. 



```python
c
```




    <__main__.Count_new_init at 0x10b817048>




```python
int("10b80c358",16)
```




    4487955288




```python
help(c)
```

    Help on Count_new_init in module __main__ object:
    
    class Count_new_init(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  counter = 4
    



```python
d = c.__init__()
```

    My name is  16  , you've Created me!



```python
id(d)
```




    4461293992




```python
e = a.__new__(Count_new_init)
```

    5  times has been called. 



```python
e
```




    <__main__.Count_new_init at 0x10b8172b0>




```python
id(e)
```




    4488000176




```python
help(e)
```

    Help on Count_new_init in module __main__ object:
    
    class Count_new_init(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  counter = 5
    


可以看出,`__new__`运算符返回的是一个对象,这个对象就是类对象,但不知为何指向的id并不相同,如果有人知道希望可以告诉我,谢谢!

### `__del__`析构运算符

析构运算符`__del__`定义当对象实例被删除或者释放时的操作,继续修改那个例子


```python
class Count_new_init__del(object):
    counter = 0
    def __new__(cls):
        cls.counter += 1
        print(cls.counter," times has been called. ")
        return super(Count_new_init__del,cls).__new__(cls)
    def __init__(self):
        self.name = self.counter<<2
        print("My name is ",self.name," , you've Created me!")
        
    def __del__(self):
        print("I'm ",self.name,", I'll leave now!")
```


```python
c = Count_new_init__del()
```

    1  times has been called. 
    My name is  4  , you've Created me!



```python
c = 1
```

    I'm  4 , I'll leave now!



```python
d = Count_new_init__del()
```

    2  times has been called. 
    My name is  8  , you've Created me!



```python
del d
```

    I'm  8 , I'll leave now!


### `__call__`运算符

类型对象函数化运算符(可以理解成重载`()`)

`__call__`常用在写API时,

> 例:建立一个类,模拟函数的参数传递


```python
class function(object):
    def __call__(self,*args,**kws):
        print("called:",args,kws)
c = function()
c(10)
```

    called: (10,) {}


> 例:建立一个被回收时会提醒的类


```python
class Life(object):
    def __init__(self,name="nodefined"):
        print(name,"诞生了")
        self.name = name
    def __del__(self):
        print("JOJO!","我",self.name,"不做人啦!!!")
Dio=Life("Dio")
Dio = "吸血鬼"
```

    Dio 诞生了
    JOJO! 我 Dio 不做人啦!!!


### `__next__`和`__iter__` 迭代器运算符

迭代器运算符,有他就说明可以用for循环遍历啥的.它是python的一大特性,与他类似的是函数式编程部分会提到的生成器.

> 迭代器

我们已经知道，可以直接作用于for循环的数据类型有以下几种：

+ 一类是集合数据类型，如list、tuple、dict、set、str等；

+ 一类是generator，包括生成器和带`yield`的generator function。

这些可以直接作用于for循环的对象统称为可迭代对象：`Iterable`。

可以使用`isinstance()`判断一个对象是否是`Iterable`对象

可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

可以使用isinstance()判断一个对象是否是Iterator对象

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

把list、dict、str等Iterable变成Iterator可以使用iter()函数.

> 例:我们来写一个输出元素三次方的类试试


```python
class ThreeTimes(object):
    def __init__(self,start,end,step=1):
        self.start = start
        self.end = end
        self.step = step
        self.n = start
    def __iter__(self):
        return self
    def __next__(self):
        print("__next__ called")
        result = self.n**3
        if self.step == 0:
            raise InputError("step must not 0!")
        elif self.step > 0:
            if self.n >= self.end:
                raise StopIteration()
            else:
                self.n=self.n+self.step
                return result
        else :
            if self.n <= self.end:
                raise StopIteration
            else:
                self.n=self.n+self.step
                return result
    def __str__(self):
        return "threetimes:"+str(list(iter(self)))
    def __repr__(self):
        return self.__str__()
```


```python
a = ThreeTimes(1,5)
a
```

    __next__ called
    __next__ called
    __next__ called
    __next__ called
    __next__ called





    threetimes:[1, 8, 27, 64]



这个例子我们可以看到`__next__`和`__iter__`是如何工作的.可以看出迭代器的写法比生成器要麻烦许多,也不够优雅,但可定制性也强了许多.

### `__enter__`和`__exit__` 上下文运算符和with关键字

我们在文件读取的时候应该已经很熟悉 with关键字了,它的用法是这样:

    with open('foo.txt') as bar:
        # 使用bar进行某些操作

当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个运算符接口所定义：

+ `__enter__(self)`

定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。注意 `__enter__` 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。

+ `__exit__(self, exception_type, exception_value, traceback)`

定义当 with 声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行， exception_type , exception_value 和 traceback 会是 None 。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保 `__exit__` 在完成工作之后返回 True 。如果你不想处理异常，那就让它发生吧。

对一些具有良好定义的且通用的设置和清理行为的类，__enter__ 和 __exit__ 会显得特别有用。你也可以使用这几个方法来创建通用的上下文管理器，用来包装其他对象。下面是一个例子:




```python
class Spliter:
    '''一个上下文管理器，可以在with语句中
    使用split()自动为string分词'''

    def __init__(self, string):
        self.string = string

    def __enter__(self):
        print("进入了",self.string)
        return self.string # 绑定到目标

    def __exit__(self, exception_type, exception_value, traceback):
        try:
                print(self.string.split(" "))
                
        except AttributeError: # obj不是可关闭的
                print('Not closable.')
                return True # 成功地处理了异常
```


```python
with Spliter("a simple example !") as string:
    print(len(string))
```

    进入了 a simple example !
    18
    ['a', 'simple', 'example', '!']


这是一个 Closer 在实际使用中的例子，使用一个FTP连接来演示（一个可关闭的socket):

### `__copy__`和`__deepcopy__`拷贝


有些时候，特别是处理可变对象时，你可能想拷贝一个对象，改变这个对象而不影响原有的对象。这时就需要用到Python的 copy 模块了。然而（幸运的是），Python模块并不具有感知能力， 因此我们不用担心某天基于Linux的机器人崛起。但是我们的确需要告诉Python如何有效率地拷贝对象。

+ `__copy__(self)`

定义对类的实例使用 copy.copy() 时的行为。 copy.copy() 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。

+ `__deepcopy__(self, emodict=)`

定义对类的实例使用 copy.deepcopy() 时的行为。 copy.deepcopy() 返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。 memodict 是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 copy.deepcopy() ，使用 memodict 作为第一个参数。

这些魔法方法有什么用武之地呢？像往常一样，当你需要比默认行为更加精确的控制时。例如，如果你想拷贝一个对象，其中存储了一个字典作为缓存（可能会很大），拷贝缓存可能是没有意义的。如果这个缓存可以在内存中被不同实例共享，那么它就应该被共享。
