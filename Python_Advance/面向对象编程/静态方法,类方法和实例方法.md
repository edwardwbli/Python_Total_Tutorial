
# 静态方法,类方法和实例方法

Python中万物皆对象,因此类也是对象,一般的实例方法只能改变实例属性,调用实例方法,如何对类对象本身,如何跳出自己只对外界使用方法呢,这就是类中的静态方法,类方法和实例方法的差别

## 实例方法:

所谓实例方法是只能改变由类构造的实例状态的方法


```python
class OA:
    def change_a(self,a):
        self.a = a
```


```python
oa=OA()
```


```python
oa.a
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-3-34b8067118ae> in <module>()
    ----> 1 oa.a
    

    AttributeError: 'OA' object has no attribute 'a'



```python
oa.change_a("a")
```


```python
oa.a
```




    'a'



可以看出,刚创建类的时候我们并没有给类中设置实例变量`a`,因此会包元素错误,之后我们调用change_a方法给实例oa创建了一个实例变量`a`并为其赋值了,因此再次调用a时就可以正常显示了.这个例子说明了实例方法是为实例服务的

# 类方法

类方法只能修改类本身这个对象的状态,它的实例也都可以调用该方法


```python
class CA:
    a=0
    @classmethod
    def change_a(cls,a):
        cls.a = a 
```


```python
ca1=CA()
ca2=CA()
```


```python
CA.change_a(10)
```


```python
CA.a
```




    10




```python
ca1.change_a(100)
```


```python
CA.a
```




    100




```python
ca1.a
```




    100




```python
ca2.change_a(1000)
```


```python
ca2.a
```




    1000




```python
CA.a
```




    1000



# 静态方法

静态方法与类,实例都无关,只是用类封装的独立方法,


```python
class SA:
    @staticmethod
    def change(a):
        return a+1
```


```python
SA.change(10)
```




    11




```python
sa=SA()
```


```python
sa.change(11)
```




    12



## 真相--绑定方法和无绑定方法

python中的类实际上可以看做是一个语法糖,类中的类方法,实例方法,静态方法实际上都只是方法,一个方法写在类里面和写在类外面没有区别，唯一不同之处就是对第一个参数有限制.所谓实例方法就是第一个参数是self，所谓类方法就是第一个参数是class，而静态方法不需要额外的参数，所以必须区分。
利用这一特点可以很灵活的使用方法,如果调用的方法是个类方法,那么就在首位给他传入一个类对象,是实例对象就传入实例,没有就不管.这就是绑定方法和无绑定的本质.
python里并没有真正意义上的静态方法，因为类定义本身也是个实例（继承自object的为type实例，裸的为classobj实例），因此一个“静态方法”其实只不过是类定义对象的成员罢了……

python中几乎全部都是对象实例,函数式对象实例,类也是对象实例.因此对python而言其实连方法这一说都不准确…那些个对象方法只不过是指向函数对象的引用，只是属性而已


**例1:查看一个类被实例化了多少次**


```python
class B:
    count = 0
    def __init__(self):
        B.count +=1
    @staticmethod
    def read_count_static():
        return B.count
    @classmethod
    def read_count_class(cls):
        return cls.count
```


```python
b1=B()
```


```python
b2 = B()
```


```python
B.read_count_static()
```




    2




```python
B.read_count_class()
```




    2



**例2:方法绑定**


```python
class Bigfish(object):
    def eat(self,n):
        print(self.__class__.__name__,"eat",n,"smallfish")
```


```python
#一般的用法
bigfish1 =Bigfish()
bigfish1.eat(2)
```

    Bigfish eat 2 smallfish



```python
#有绑定的方法:
bigfish2 = Bigfish()
eat = bigfish2.eat
eat(4)
```

    Bigfish eat 4 smallfish



```python
# 无绑定方法:
bigfish3 = Bigfish()
eat = Bigfish.eat
eat(bigfish3,5)
```

    Bigfish eat 5 smallfish


python中的类实际上可以看做是一个语法糖,类中的类方法,实例方法,静态方法实际上都只是方法,不同之处就是对第一个参数的限制,利用这一特点可以很灵活的使用方法,如果调用的方法是个类方法,那么就在首位给他传入一个类对象,是实例对象就传入实例,没有就不管.这就是绑定方法和无绑定的本质
